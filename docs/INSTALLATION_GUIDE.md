# Installation Guide

## Quick Start

1. **Copy the wheel file** to your project directory (same folder as `requirements.in` or `requirements.txt`):
   ```bash
   cp /path/to/casdoor-python-sdk/dist/casdoor-1.40.0_cve260107-py3-none-any.whl .
   ```

2. **Add the wheel file to your requirements:**

   **Option A: Using requirements.txt directly**
   ```txt
   casdoor-1.40.0_cve260107-py3-none-any.whl
   ```

   **Option B: Using requirements.in with pip-compile**
   ```txt
   casdoor-1.40.0_cve260107-py3-none-any.whl
   ```

3. **If using pip-compile, run it:**
   ```bash
   pip-compile @requirements.in -o requirements.txt --skip-extras
   ```

4. **Post-process requirements.txt (if using pip-compile):**
   
   `pip-compile` may generate absolute paths. Remove them and make the path relative:
   ```bash
   # Replace absolute paths with just the filename
   sed -i '' 's|.*/casdoor-.*\.whl|casdoor-1.40.0_cve260107-py3-none-any.whl|g' requirements.txt
   ```
   
   Or manually edit `requirements.txt` to change:
   ```txt
   /absolute/path/to/casdoor-1.40.0_cve260107-py3-none-any.whl
   ```
   
   To:
   ```txt
   casdoor-1.40.0_cve260107-py3-none-any.whl
   ```

5. **Install:**
   ```bash
   pip install -r requirements.txt
   ```

## Example

**Project structure:**
```
my-project/
├── requirements.in
├── requirements.txt
└── casdoor-1.40.0_cve260107-py3-none-any.whl
```

**requirements.in:**
```txt
requests>=2.28.0
flask>=2.0.0
casdoor-1.40.0_cve260107-py3-none-any.whl
```

**After running `pip-compile requirements.in -o requirements.txt --skip-extras` and fixing paths, requirements.txt:**
```txt
#
# This file is autogenerated by pip-compile
#
aiohttp==3.13.3
    # via casdoor (from casdoor-1.40.0_cve260107-py3-none-any.whl)
casdoor-1.40.0_cve260107-py3-none-any.whl
    # via -r requirements.in
flask==2.3.3
    # via -r requirements.in
requests==2.32.5
    # via -r requirements.in
```

## Dockerfile Example

When using Docker, copy `requirements.in` and wheel files into the container, then run `pip-compile` inside the Dockerfile. This avoids path issues since `pip-compile` will use the relative paths from within the container:

**Dockerfile:**
```dockerfile
FROM python:3.11-slim

WORKDIR /code

# Copy app and requirements
COPY ./requirements.in /code/requirements.in

# Copy local wheel files (if present in build context)
COPY casdoor-*.whl /code/

# Install Python dependencies in venv
RUN pip install --upgrade pip pip-tools \
    && pip-compile @/code/requirements.in -o /code/requirements.txt --skip-extras \
    && pip install --no-cache-dir -r /code/requirements.txt \
    && rm -rf ~/.cache/pip

# Copy application code
COPY . /code/

# Your application startup command
CMD ["python", "app.py"]
```

**Benefits:**
- ✅ No need to post-process paths - `pip-compile` generates correct relative paths inside container
- ✅ `requirements.in` stays in source control (not the generated `requirements.txt`)
- ✅ Fresh dependency resolution on each build
- ✅ Wheel files are copied into build context before `pip-compile` runs

**Note:** Make sure wheel files are in your build context (same directory or subdirectory of Dockerfile) so `COPY casdoor-*.whl /code/` can find them.
